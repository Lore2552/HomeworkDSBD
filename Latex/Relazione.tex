\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{tabularx}
\usepackage{url}

\newcolumntype{L}{>{\raggedright\arraybackslash}X}

\title{Relazione Homework DSBD}
\author{Lorenzo Varsallona - Paola Pappalardo}
\date{\today}

\begin{document}

\maketitle

\section{Introduzione e Obiettivi}

Il presente documento illustra il funzionamento e le decisioni progettuali adottate per lo sviluppo dell'applicativo.
In particolare, nelle sezioni successive si approfondirà quanto è stato utilizzato e il funzionamento dei microservizi implementati, con particolare enfasi sulle scelte architetturali che hanno guidato la progettazione del sistema.

\subsection{Architettura Generale}

L'applicativo è stato strutturato secondo un'architettura a microservizi, suddiviso in più moduli Python per garantire una suddivisione pulita, elegante e modulare del codice. Questa scelta architetturale consente il riutilizzo di componenti comuni e facilita la manutenzione futura del sistema.

L'applicativo prevede due microservizi principali:
\begin{itemize}
  \item \textbf{User-Manager}: responsabile della gestione degli utenti e della memorizzazione dei dati anagrafici.
  \item \textbf{Data-Collector}: responsabile della raccolta dati di voli da API esterne e della gestione delle preferenze aeroportuali degli utenti.
\end{itemize}

Questi due microservizi comunicano tra loro tramite un canale gRPC bidirezionale.

\subsection{Infrastruttura e Database}

Per il database, vista la semplicità attuale del progetto, si è deciso di utilizzare due database PostgreSQL distinti (uno per ogni microservizio) situati all'interno dello stesso container. Questa decisione facilita lo sviluppo e il testing in ambienti locali, consentendo successivamente di scalare i database su container separati o servizi gestiti senza modificare l'applicazione.

\subsection{Politica di Idempotenza e Affidabilità}

Un requisito fondamentale del progetto è l'implementazione della politica \textit{at-most-once} per evitare la duplicazione dei messaggi. Questo è stato realizzato attraverso un meccanismo di cache basato su \textit{message IDs} (identificatori univoci per ogni richiesta) memorizzati nel database con scadenza temporale (5 minuti).

Quando una richiesta viene elaborata, il message ID e la risposta vengono salvati in cache. Se la stessa richiesta viene ricevuta entro il periodo di scadenza, il sistema restituisce la risposta memorizzata senza rielaborare l'operazione, garantendo così l'idempotenza.

\subsection{Fonte Dati e Funzionalità}

L'API OpenSky è stata scelta come fonte dati principale per la raccolta delle informazioni di volo. Questa API fornisce accesso a dati reali di aviazione civile, permettendo di implementare tutte le funzionalità richieste dalla specifica, oltre ad alcune funzionalità aggiuntive che verranno approfondite nelle sezioni seguenti.

I dati vengono raccolti secondo una finestra temporale specifica, scalata di 2 ore indietro per garantire la \textit{data availability} dei voli, e questi ultimi vengono sincronizzati periodicamente con una frequenza di 12 ore.

\section{Architettura del sistema e decomposizione}

In questa sezione si approfondiranno gli aspetti implementativi adottati all'interno dell'applicativo, con particolare attenzione alle scelte tecnologiche e architetturali.

\subsection{Database}

L'applicativo utilizza due database PostgreSQL distinti:
\begin{itemize}
  \item \textbf{userdb}: gestisce i dati anagrafici degli utenti e la cache per l'idempotenza dei messaggi.
  \item \textbf{datadb}: gestisce i dati di volo e le preferenze aeroportuali degli utenti.
\end{itemize}

\noindent Per l'interazione con i database PostgreSQL, è stato scelto \textbf{SQLAlchemy} tramite l'integrazione \texttt{Flask-SQLAlchemy}. Questa scelta offre numerosi vantaggi:

\begin{itemize}
  \item \textbf{Astrazione dal database}: il codice Python rimane indipendente dal motore SQL specifico.
  \item \textbf{Type safety}: i modelli ORM garantiscono type checking e validazione a livello applicativo.
  \item \textbf{Query builder}: le query vengono costruite direttamente tramite funzioni di SQLAlchemy, riducendo anche il rischio di SQL-Injection.
  \item \textbf{Relationship}: gestione automatica e semplificata delle relazioni tra tabelle.
  \item \textbf{Session management}: gestione automatica delle transazioni e del ciclo di vita degli oggetti in memoria (commit, rollback, ecc).
\end{itemize}

Inoltre, SQLAlchemy consente di definire il modello dati interamente in Python, sincronizzando automaticamente lo schema del database tramite \texttt{db.create\_all()}.

\subsubsection{Database userdb}

Il database userdb contiene due tabelle principali, gestite attraverso i modelli ORM definiti nel file \texttt{models.py}:

\paragraph{Tabella \texttt{users}}

Questa tabella memorizza i dati anagrafici degli utenti registrati nel sistema:

\vspace{0.2cm}
\noindent
\begin{tabularx}{\textwidth}{|L|L|L|}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Vincolo} \\
\hline
\texttt{email} & \texttt{VARCHAR(255)} & PK \\
\texttt{name} & \texttt{VARCHAR(255)} & NOT NULL \\
\texttt{surname} & \texttt{VARCHAR(255)} & NOT NULL \\
\texttt{fiscal\_code} & \texttt{VARCHAR(16)} & Nullable \\
\texttt{bank\_info} & \texttt{VARCHAR(200)} & Nullable \\
\hline
\end{tabularx}
\vspace{0.2cm}

\paragraph{Tabella \texttt{message\_ids}}

Questa tabella implementa il meccanismo di cache per la politica \textit{at-most-once}, memorizzando gli ID dei messaggi già elaborati:

\vspace{0.2cm}
\noindent
\begin{tabularx}{\textwidth}{|L|L|L|}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Vincolo} \\
\hline
\texttt{id} & \texttt{VARCHAR(36)} & PK \\
\texttt{response\_\allowbreak data} & \texttt{JSON} & Nullable \\
\texttt{response\_\allowbreak status} & \texttt{INTEGER} & Nullable \\
\texttt{expires\_at} & \texttt{TIMESTAMP} & NOT NULL \\
\hline
\end{tabularx}
\vspace{0.2cm}

L'utilizzo del tipo \texttt{JSON} per memorizzare \texttt{response\_data} consente di salvare risposte di qualsiasi forma senza necessità di schema predefinito. Un processo di pulizia periodico (cleanup job schedulato ogni 5 minuti) rimuove automaticamente i record scaduti, evitando la crescita indefinita della tabella.

\subsubsection{Database datadb}

Il database datadb contiene due tabelle principali, gestite attraverso i modelli ORM definiti nel file \texttt{models.py}:

\paragraph{Tabella \texttt{user\_airports}}

Questa tabella implementa la relazione molti-a-molti tra utenti e aeroporti monitorati:

\vspace{0.2cm}
\noindent
\begin{tabularx}{\textwidth}{|L|L|L|}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Vincolo} \\
\hline
\texttt{id} & \texttt{INTEGER} & PK \\
\texttt{user\_email} & \texttt{VARCHAR(255)} & NOT NULL \\
\texttt{airport\_code} & \texttt{VARCHAR(10)} & NOT NULL \\
\hline
\end{tabularx}
\vspace{0.2cm}

Ogni riga rappresenta l'iscrizione di un utente al monitoraggio di un determinato aeroporto. La coppia \texttt{(user\_email, airport\_code)} deve essere univoca per evitare duplicati.

\paragraph{Tabella \texttt{flights}}

Questa tabella memorizza i dati di volo raccolti periodicamente dall'API OpenSky.

\vspace{0.2cm}
\noindent
\begin{tabularx}{\textwidth}{| >{\hsize=1.4\hsize}L | >{\hsize=0.8\hsize}L | >{\hsize=0.8\hsize}L |}
\hline
\textbf{Campo} & \textbf{Tipo} & \textbf{Vincolo} \\
\hline
\texttt{id} & \texttt{INTEGER} & PK \\
\texttt{icao24} & \texttt{VARCHAR(20)} & Nullable \\
\texttt{callsign} & \texttt{VARCHAR(20)} & Nullable \\
\texttt{est\_departure\_\allowbreak airport} & \texttt{VARCHAR(10)} & Nullable \\
\texttt{est\_arrival\_\allowbreak airport} & \texttt{VARCHAR(10)} & Nullable \\
\texttt{first\_seen} & \texttt{INTEGER} & Nullable \\
\texttt{last\_seen} & \texttt{INTEGER} & Nullable \\
\texttt{airport\_\allowbreak monitored} & \texttt{VARCHAR(10)} & Nullable \\
\texttt{direction} & \texttt{VARCHAR(10)} & Nullable \\
\hline
\end{tabularx}
\vspace{0.2cm}

I campi \texttt{first\_seen} e \texttt{last\_seen} memorizzano timestamp. Il campo \texttt{direction} può assumere i valori 'arrival' o 'departure' per distinguere i voli in arrivo da quelli in partenza. La deduplicazione durante la raccolta si basa sulla combinazione univoca \texttt{(icao24, first\_seen, airport\_monitored, direction)}.

\subsection{Microservizio user-manager}

Il microservizio \textbf{user-manager} è responsabile della gestione del ciclo di vita degli utenti: registrazione, eliminazione e gestione delle loro preferenze aeroportuali. Il servizio è costruito su Flask e implementa sia endpoint HTTP REST per l'interazione con i client, sia un server gRPC per la comunicazione bidirezionale con il microservizio data-collector.

\subsubsection{Architettura Interna}

L'applicazione è strutturata mediante tre componenti principali, definiti in altrettanti moduli Python:

\begin{sloppypar}
\begin{itemize}
  \item \textbf{user-manager.py}: punto di ingresso dell'applicazione. Inizializza il database tramite \texttt{db.create\_all()}, avvia lo scheduler di background per la pulizia periodica della cache di idempotenza (ogni 5 minuti), e istanzia il thread gRPC che rimane in ascolto su porta 50051.
  \item \textbf{routes.py}: contiene i tre endpoint REST principali esposti dal servizio, ognuno dei quali gestisce logica di business specifica e comunica con il data-collector tramite gRPC.
  \item \textbf{grpc\_service.py}: implementa il server gRPC con i servizi definiti nel file proto (\texttt{UserService} e \texttt{CollectorService}).
\end{itemize}
\end{sloppypar}

\subsubsection{Endpoint REST}

Il microservizio espone tre endpoint HTTP principali su porta 5000:

\begin{sloppypar}
\begin{itemize}
  \item \textbf{POST /addUser}: crea un nuovo utente nel database. Implementa la politica \textit{at-most-once} controllando innanzitutto se il \texttt{message\_id} esiste già in cache; in caso affermativo, restituisce la risposta precedentemente memorizzata. Successivamente, valida l'unicità dell'email e del codice fiscale. Se tutti i controlli hanno esito positivo, salva l'utente e la coppia \texttt{(message\_id, response)} nella cache con TTL di 5 minuti. Ritorna HTTP 201 (Created) per successo, 409 (Conflict) per duplicati.
  
  \item \textbf{DELETE /deleteUser}: elimina un utente dal database in base all'email fornita. Dopo aver rimosso l'utente da userdb, comunica immediatamente con il data-collector via gRPC tramite il metodo \texttt{CleanupUser()}, notificando al secondo servizio di rimuovere tutti i dati associati a quell'utente (voli, preferenze aeroportuali). Questo garantisce la coerenza tra i due database.
  
  \item \textbf{DELETE /removeAirportInterest}: rimuove uno specifico aeroporto dalle preferenze monitorate di un utente. Effettua una validazione preliminare sull'esistenza dell'utente, quindi comunica con il data-collector tramite gRPC usando il metodo \texttt{RemoveAirport\allowbreak Interest()}, che provvede a rimuovere l'aeroporto dalla tabella \texttt{user\_airports} in datadb.
\end{itemize}
\end{sloppypar}

\subsubsection{Meccanismo di Cache e Idempotenza}

La cache di idempotenza è implementata attraverso la tabella \texttt{message\_ids} in userdb. Ogni richiesta POST a \texttt{/addUser} deve includere un identificatore univoco \texttt{message\_id} nel corpo della richiesta. Prima di elaborare l'operazione:

\begin{enumerate}
  \item Il sistema interroga la cache per verificare se il \texttt{message\_id} è stato già elaborato.
  \item Se presente, restituisce immediatamente la risposta memorizzata senza eseguire duplicati.
  \item Se assente, procede con l'elaborazione e salva sia il risultato che l'ID nella cache con scadenza.
\end{enumerate}

\subsubsection{Comunicazione gRPC}

Il microservizio implementa due servizi gRPC definiti nel file \texttt{user\_manager.proto}:

\begin{itemize}
  \item \textbf{UserService}: offre i metodi \texttt{CheckUser()} e \texttt{GetUser()} per permettere al data-collector di verificare l'esistenza di un utente e recuperarne i dati anagrafici. Questi metodi sono invocati dal data-collector quando un utente effettua operazioni che richiedono validazione.
  \item \textbf{CollectorService}: espone i metodi \texttt{CleanupUser()} e \texttt{RemoveAirport\allowbreak Interest()} che ricevono richieste dal data-collector per sincronizzare le operazioni.
\end{itemize}

\subsection{Microservizio data-collector}

Il microservizio \textbf{data-collector} è responsabile della raccolta periodica dei dati di volo dall'API OpenSky e della gestione delle preferenze aeroportuali degli utenti. Analogamente a user-manager, è costruito su Flask ed espone sia endpoint HTTP REST per operazioni sincrone e query, sia un server gRPC per ricevere notifiche di modifica dai dati gestiti da user-manager.

\subsubsection{Architettura Interna}

L'applicazione è strutturata in diverse componenti principali:

\begin{sloppypar}
\begin{itemize}
  \item \textbf{data-collector.py}: punto di ingresso dell'applicazione. Inizializza il database tramite \texttt{db.create\_all()}, avvia uno scheduler di background che esegue la raccolta periodica dei voli ogni 12 ore mediante la funzione \texttt{run\_scheduled\_\allowbreak flights()}, e istanzia il thread gRPC che rimane in ascolto su porta 50052.
  \item \textbf{routes.py}: contiene i molteplici endpoint REST che espongono funzionalità di query sui dati di volo, registrazione delle preferenze aeroportuali, e strumenti di debug. Tutti gli endpoint che modificano dati aeroportuali comunicano con user-manager tramite gRPC per validare l'esistenza degli utenti.
  \item \textbf{grpc\_service.py}: implementa il server gRPC con il servizio \texttt{CollectorService}, che riceve richieste da user-manager per sincronizzare le operazioni di eliminazione (\texttt{CleanupUser} e \texttt{RemoveAirport\allowbreak Interest}).
  \item \textbf{services.py}: contiene la logica di raccolta dei dati di volo. La funzione \texttt{collect\_flights()} interroga l'API OpenSky per arrivals e departures, deduplica i voli, e li salva in datadb.
  \item \textbf{token\_manager.py}: gestisce l'autenticazione OAuth2 con l'API OpenSky, fornendo token validi per le richieste autenticate.
\end{itemize}
\end{sloppypar}

\subsubsection{Endpoint REST}

Il microservizio espone i seguenti endpoint HTTP su porta 5001:

\begin{sloppypar}
\begin{itemize}
  \item \textbf{POST /register\_airports}: registra gli interessi aeroportuali di un utente. Prima valida l'esistenza dell'utente tramite gRPC con user-manager (\texttt{CheckUser}), poi salva le coppie \texttt{(email, airport\_code)} nella tabella \texttt{user\_airports}. Successivamente, avvia in background un thread che esegue immediatamente la raccolta dati (\texttt{collect\_flights}) per i soli aeroporti registrati, popolando il database con i voli storici. Ritorna HTTP 200 se la registrazione ha successo.
  
  \item \textbf{GET /user\_info/<email>}: recupera le informazioni complete su un utente, combinando i dati anagrafici provenienti da user-manager (via gRPC \texttt{GetUser}) con l'elenco degli aeroporti di interesse salvati localmente. Ritorna 404 se l'utente non esiste in user-manager.
  
  \item \textbf{GET /airports/<airport\_code>/\allowbreak last\_flight}: restituisce l'ultimo volo registrato per un dato aeroporto. Supporta un parametro query opzionale ``direction'' ('arrival' o 'departure') per filtrare i risultati.
  
  \item \textbf{GET /airports/<airport\_code>/\allowbreak average\_flights}: calcola la media di voli per giorno per un aeroporto, in una finestra temporale configurabile (parametro ``days'', default 7). Supporta filtro opzionale per direzione.
  
  \item \textbf{GET /airports/<airport\_code>/\allowbreak busiest\_hour}: identifica l'ora UTC con il maggior numero di voli per un aeroporto. Estrae l'ora da tutti i timestamp registrati e utilizza una struttura Counter per determinare l'ora più frequente.
\end{itemize}
\end{sloppypar}

\subsubsection{Raccolta Dati e Deduplicazione}

La funzione \texttt{collect\_flights()} in \texttt{services.py} implementa la logica di raccolta rispettando la seguente procedura:

\begin{sloppypar}
\begin{enumerate}
  \item Determina la lista degli aeroporti da monitorare: se non vengono specificati nel parametro ``target\_airports'', interroga il database per recuperare tutti gli aeroporti con almeno un utente interessato.
  \item Calcola la finestra temporale: ultimi 12 ore, escludendo le ultime 2 ore per garantire la disponibilità dei dati.
  \item Per ogni aeroporto, esegue due richieste all'API: una per arrivals e una per departures.
  \item Implementa la deduplicazione: prima di inserire un volo nel database, controlla che non esista già un volo con lo stesso \texttt{icao24}, \texttt{first\_seen}, \texttt{airport\_monitored} e \texttt{direction}. Questo previene l'accumulo di duplicati se la raccolta viene eseguita più volte.
  \item Salva i dati nel database e genera statistiche sull'operazione (numero di aeroporti elaborati, voli aggiunti, errori).
\end{enumerate}
\end{sloppypar}

\subsubsection{Comunicazione gRPC}

Il microservizio implementa il servizio \texttt{CollectorService} definito nel file \texttt{user\_manager.proto}:

\begin{itemize}
  \item \textbf{CleanupUser(email)}: richiesta ricevuta da user-manager quando un utente viene eliminato. Il metodo:
  \begin{enumerate}
    \item Recupera tutti gli aeroporti di interesse dell'utente.
    \item Per ogni aeroporto, verifica se altri utenti lo hanno sottoscritto.
    \item Se nessun altro utente è interessato, elimina tutti i voli associati a quell'aeroporto.
    \item Elimina tutte le righe da \texttt{user\_airports} relative all'utente.
    \item Ritorna un messaggio di successo con il conteggio degli elementi rimossi.
  \end{enumerate}
  
  \item \textbf{RemoveAirportInterest(email, airport\_code)}: richiesta ricevuta da user-manager quando un utente rimuove un aeroporto dalle sue preferenze. Il metodo:
  \begin{enumerate}
    \item Valida che l'interesse esista nel database.
    \item Elimina la riga corrispondente da \texttt{user\_airports}.
    \item Verifica se altri utenti sono interessati allo stesso aeroporto.
    \item Se non ci sono altri utenti, elimina tutti i voli associati.
    \item Ritorna il numero di voli eliminati.
  \end{enumerate}
\end{itemize}

\subsubsection{Canale gRPC bidirezionale}

La scelta di implementare un canale gRPC bidirezionale tra i due microservizi è stata una decisione progettuale deliberata, giustificata dai seguenti aspetti:

\noindent Un'architettura puramente unidirezionale da data-collector verso user-manager si sarebbe limitata al data-collector che interroga user-manager per validare gli utenti (tramite \texttt{CheckUser()} e \texttt{GetUser()}). Tuttavia, questa soluzione non avrebbe consentito il flusso inverso di notifiche critiche.

Quando user-manager effettua operazioni di modifica (eliminazione di utenti o rimozione di preferenze aeroportuali), è necessario notificare data-collector affinché esegua la sincronizzazione: eliminare i voli associati e pulire la tabella \texttt{user\_airports}. 

\subsubsection{Politiche di comunicazione}

Il sistema implementa la semantica \textbf{at-most-once} per garantire che ogni operazione venga elaborata al massimo una volta, prevenendo gli effetti indesiderati di retry accidentali o duplicati di rete.

Il meccanismo si basa su un identificatore univoco \texttt{message\_id} fornito dal client in ogni richiesta POST a \texttt{/addUser}. Il flusso è il seguente:

\begin{enumerate}
  \item Il client genera un \texttt{message\_id} (tipicamente un UUID) e lo include nel payload JSON.
  
  \item user-manager interroga la tabella \texttt{message\_ids} in userdb per verificare se il \texttt{message\_id} è stato già elaborato.
  
  \item Se il record esiste e non è scaduto (TTL = 5 minuti), il servizio restituisce immediatamente la risposta memorizzata (\texttt{response\_data} e \texttt{response\_status}) senza rielaborare l'operazione. Questo garantisce idempotenza: invocazioni ripetute della stessa richiesta producono il medesimo risultato.
  
  \item Se il record non esiste o è scaduto, l'operazione viene elaborata, il risultato viene salvato nella cache con timestamp di scadenza, e la risposta viene ritornata al client.
  
  \item Un job di background eseguito ogni 5 minuti ripulisce i record scaduti, evitando la crescita indefinita della tabella di cache.
\end{enumerate}

\noindent Questa implementazione protegge da scenari comuni di fallimento della rete (timeouts, disconnessioni) dove il client, non ricevendo una risposta entro il tempo limite, reinvia la richiesta. La cache di idempotenza assicura che il secondo invio non produca effetti secondari (duplicate user creation, conflitti di vincoli).

Le operazioni DELETE (\texttt{/deleteUser}, \texttt{/removeAirportInterest}) sono intrinseciamente idempotenti nel loro design:

\begin{itemize}
  \item \textbf{/deleteUser}: se l'utente non esiste al secondo invio, il servizio restituisce un errore 404 consistente con il primo tentativo. La richiesta gRPC a data-collector via \texttt{CleanupUser()} gestisce gracefully il caso in cui l'utente non possieda aeroporti registrati: semplicemente non elimina nulla e ritorna success=true.
  
  \item \texttt{/removeAirportInterest}: la richiesta gRPC \texttt{RemoveAirportInterest()} valida l'esistenza del record (user\_email, airport\_code) prima di eliminarlo. Se non esiste, ritorna success=false con un messaggio descrittivo, permettendo al client di distinguere tra ``non trovato al primo tentativo'' e ``non trovato al retry''.
\end{itemize}


\end{document}