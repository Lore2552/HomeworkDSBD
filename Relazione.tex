\documentclass[11pt]{article} % Aumenta la dimensione del font a 11pt per migliore leggibilità
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{float}

% Pacchetti per migliorare l'impaginazione
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 } % Imposta margini più ampi e definiti (es. 20mm su tutti i lati)

\usepackage{graphicx}
\usepackage{microtype}
\usepackage{tabularx}
\usepackage{url}
\usepackage{parskip} % Rimuove l'indentazione e usa spazio verticale tra i paragrafi
\usepackage{booktabs} % Per tabelle professionali con linee orizzontali eleganti
\usepackage{makecell} % Per andare a capo nelle celle delle tabelle
% Pacchetto per personalizzare l'indice (opzionale, ma consigliato per i documenti più lunghi)
\usepackage{tocloft} 

\newcolumntype{L}{>{\raggedright\arraybackslash}X}

\title{Relazione Homework 2 DSBD}
\author{Lorenzo Varsallona (1000084765) - Paola Pappalardo (1000035439)}
\date{}

\begin{document}

\maketitle

% INSERIMENTO DEL SOMMARIO (INDICE) QUI
\tableofcontents 
\newpage % Inizia la prima sezione su una nuova pagina per chiarezza

\section{Introduzione e Obiettivi}
Il presente documento illustra le modifiche apportate e le decisioni progettuali prese per la seconda parte dell'homework.
L'obiettivo principale è stato quello di evolvere l'architettura del sistema verso un approccio a microservizi più robusto e scalabile, introducendo meccanismi di comunicazione asincrona tramite Kafka, pattern di resilienza come il Circuit Breaker e un sistema di notifica via email.

Nelle sezioni successive, si andranno ad approfondire le nuove funzionalità introdotte nell'applicazione, tra le quali l'integrazione con Apache Kafka, l'implementazione del Circuit Breaker nel Data Collector e la gestione delle notifiche di allerta.

\section{Architettura del sistema e decomposizione}

In questa sezione si approfondiranno gli aspetti implementativi adottati all'interno dell'applicativo, con particolare attenzione alle nuove scelte tecnologiche e architetturali introdotte per soddisfare i requisiti della seconda parte dell'homework.
\begin{figure}[H] 
    \centering 
    \includegraphics[width=0.8\textwidth]{schema_architetturale.jpg} 
    \caption{Diagramma architetturale generale del sistema.} 
    \label{fig:architettura} 
\end{figure}

\subsection{Architettura Generale}

L'applicativo è stato strutturato secondo un'architettura a microservizi, che è stata estesa rispetto alla versione precedente per garantire maggiore scalabilità e resilienza.
Oltre ai microservizi originali (\textbf{User-Manager} e \textbf{Data-Collector}), l'architettura ora comprende:

\begin{itemize}
  \item \textbf{Alert-System}: nuovo microservizio responsabile dell'elaborazione degli eventi di volo e della verifica delle soglie di allerta.
  \item \textbf{Alert-Notifier-System}: nuovo microservizio responsabile dell'invio delle notifiche via email.
\end{itemize}

La comunicazione tra i servizi è stata arricchita: mentre User-Manager e Data-Collector continuano a comunicare via gRPC, l'interazione verso i nuovi servizi di allerta avviene in modo asincrono tramite il message broker \textbf{Apache Kafka}.
Inoltre, per migliorare la robustezza delle chiamate verso API esterne, è stato introdotto il pattern \textbf{Circuit Breaker} nel Data-Collector.

\subsection{Database}

Le modifiche allo schema dati si sono concentrate sul database \textbf{datadb}, specificamente per supportare la gestione delle soglie di allerta personalizzate.

\paragraph{Tabella \texttt{user\_airports}}

Questa tabella, che memorizza le associazioni tra utenti e aeroporti, è stata modificata aggiungendo le colonne per le soglie:

\begin{center}
\begin{tabularx}{0.8\textwidth}{L L L} 
\toprule 
\textbf{Campo} & \textbf{Tipo} & \textbf{Vincolo} \\
\midrule 
\texttt{id} & \texttt{INTEGER} & PK, Autoincrement \\
\texttt{user\_email} & \texttt{VARCHAR(255)} & NOT NULL \\
\texttt{airport\_code} & \texttt{VARCHAR(10)} & NOT NULL \\
\texttt{high\_value} & \texttt{INTEGER} & Nullable \\
\texttt{low\_value} & \texttt{INTEGER} & Nullable \\
\bottomrule 
\end{tabularx}
\end{center}

\section{Modifiche al Data Collector}
Il componente \texttt{data-collector} è stato aggiornato per migliorare l'affidabilità e disaccoppiare la raccolta dati dall'elaborazione degli allarmi.

\subsection{Gestione Interessi Utente}
L'API \texttt{/register\_airports} è stata estesa per supportare la definizione di soglie personalizzate per ogni aeroporto monitorato.
Ora, oltre al codice dell'aeroporto, l'utente può specificare opzionalmente:
\begin{itemize}
    \item \texttt{high\_value}: soglia massima di voli, superata la quale si desidera ricevere un allarme.
    \item \texttt{low\_value}: soglia minima di voli, al di sotto della quale si desidera ricevere un allarme.
\end{itemize}
È possibile registrare un aeroporto senza specificare alcuna soglia. 
Le soglie possono essere aggiunte successivamente, sia singolarmente che entrambe, tramite una nuova chiamata allo stesso endpoint, che aggiornerà i valori esistenti.
Il sistema valida che, se presenti entrambi, il valore massimo sia strettamente maggiore del minimo.
\begin{figure}[H] 
    \centering 
    \includegraphics[width=0.8\textwidth]{1. register_airports.png} 
    \caption{Diagramma di sequenza GET/airports/<airport\_code>/busiest\_hour} 
    \label{fig:sq busiestHour} 
\end{figure}

Inoltre, è stata introdotta una nuova rotta per la gestione delle thresholds:
\begin{itemize}
    \item \texttt{/airports/deleteThresholds}: (metodo DELETE, esposta dal Data Collector) consente di rimuovere le soglie personalizzate (\texttt{high\_value} e \texttt{low\_value}) per un aeroporto specifico, mantenendo però l'interesse attivo. In questo modo l'utente continua a monitorare l'aeroporto ma non riceverà più allarmi basati sulle soglie precedentemente impostate.
    \begin{figure}[H] 
    \centering 
    \includegraphics[width=0.6\textwidth]{2. airtports_deleteThresholds.png} 
    \caption{Diagramma di sequenza GET/airports/<airport\_code>/busiest\_hour} 
    \label{fig:sq busiestHour} 
    \end{figure}
\end{itemize}

\subsection{Circuit Breaker}
Per gestire eventuali fallimenti o latenze eccessive nelle chiamate alle API esterne di OpenSky, è stato implementato il pattern \textbf{Circuit Breaker}.
Il meccanismo è configurato con una soglia di fallimento (\texttt{failure\_threshold}) di 3 tentativi e un timeout di recupero (\texttt{recovery\_timeout}) di 60 secondi. Questo previene il sovraccarico del servizio remoto in caso di disservizi e permette al sistema di fallire velocemente (fail-fast) senza bloccare le risorse.

\subsection{Comunicazione tramite Kafka}
Una volta raccolti i dati, il sistema agisce come un \textbf{Kafka Producer}.
Nello specifico, ogni volta che viene eseguita la funzione \texttt{collect\_flights} (invocata periodicamente o scatenata dalla registrazione di nuovi aeroporti tramite \texttt{/register\_airports}), il servizio pubblica un messaggio sul topic \texttt{to-alert-system}.
Questo messaggio contiene il conteggio aggiornato dei voli per ogni aeroporto monitorato, permettendo un'elaborazione asincrona e scalabile da parte del sistema di allerta.

Per ottimizzare l'affidabilità e l'efficienza della trasmissione, il Producer è stato configurato con i seguenti parametri:
\begin{itemize}
    \item \texttt{acks='all'}: Garantisce la massima durabilità dei dati, richiedendo la conferma di scrittura da tutte le repliche in-sync (ISR) prima di considerare il messaggio inviato con successo.
    \item \texttt{retries=5}: Aumenta la resilienza del sistema, permettendo al producer di riprovare l'invio in caso di errori transitori (es. elezione di un nuovo leader) senza perdere messaggi.
    \item \texttt{batch.size=32768} (32KB): Incrementa la dimensione del batch per favorire l'invio cumulativo di messaggi, migliorando il throughput di rete.
    \item \texttt{linger.ms=20}: Introduce una latenza intenzionale di 20ms per permettere al buffer di riempirsi maggiormente prima dell'invio, riducendo il numero di richieste I/O verso il broker.
\end{itemize}

\section{Nuovi microservizi che utilizzano Kafka}
In questa sezione verranno analizzati i due nuovi microservizi implementati: Alert System e Alert Notifier System.
\subsection{Alert System}
Il nuovo microservizio \texttt{alert-system} è stato introdotto per gestire la logica di business relativa al monitoraggio delle soglie.

\subsubsection{Avvio e Connessione}
All'avvio del servizio, è stato introdotto un ritardo intenzionale (\texttt{time.sleep(20)}) prima di tentare la connessione a Kafka.
Questa attesa è necessaria per garantire che i broker Kafka siano completamente avviati e pronti ad accettare connessioni, evitando errori di connessione ("Broker not available") durante la fase di startup dell'infrastruttura Docker Compose.

\subsubsection{Configurazione Kafka}
Il servizio utilizza la libreria \texttt{confluent-kafka} sia come Consumer che come Producer.

A livello di infrastruttura (Docker Compose), è stata adottata la modalità \textbf{KRaft (Kafka Raft Metadata mode)}. Questa architettura rimuove la dipendenza da Zookeeper, semplificando il deployment e la gestione del cluster. Il broker agisce quindi autonomamente sia per la gestione dei dati che per il coordinamento del cluster (controller).
Di seguito i parametri di configurazione utilizzati per abilitare questa modalità in un ambiente a singolo nodo:
\begin{itemize}
    \item \texttt{KAFKA\_NODE\_ID: 1}: Identificativo univoco del nodo nel cluster.
    \item \texttt{KAFKA\_PROCESS\_ROLES: 'broker,controller'}: Il nodo agisce sia come broker (gestione dati) che come controller (gestione metadati), tipico delle configurazioni single-node KRaft.
    \item \texttt{KAFKA\_CONTROLLER\_QUORUM\_VOTERS: '1@kafka:9093'}: Definisce il quorum dei votanti per il controller; essendo un solo nodo, vota se stesso.
    \item \texttt{KAFKA\_LISTENERS} e \texttt{KAFKA\_ADVERTISED\_LISTENERS}: Configurano gli endpoint di ascolto. La porta 9092 è usata per i client (PLAINTEXT), mentre la 9093 per il traffico interno del controller.
    \item \texttt{KAFKA\_LISTENER\_SECURITY\_PROTOCOL\_MAP}: Mappa i nomi dei listener ai protocolli di sicurezza (qui PLAINTEXT non criptato).
    \item \texttt{KAFKA\_INTER\_BROKER\_LISTENER\_NAME: 'PLAINTEXT'}: Definisce il protocollo per la comunicazione tra broker.
    \item \texttt{KAFKA\_CONTROLLER\_LISTENER\_NAMES: 'CONTROLLER'}: Definisce il listener usato dal controller.
    \item \texttt{KAFKA\_OFFSETS\_TOPIC\_REPLICATION\_FACTOR: 1}: Imposta la replica del topic degli offset a 1 (nessuna ridondanza), adeguato per sviluppo locale.
    \item \texttt{KAFKA\_TRANSACTION\_STATE\_LOG\_REPLICATION\_FACTOR: 1}: Imposta la replica del log delle transazioni a 1.
    \item \texttt{KAFKA\_TRANSACTION\_STATE\_LOG\_MIN\_ISR: 1}: Numero minimo di repliche in-sync richiesto per le transazioni (1 per single-node).
    \item \texttt{KAFKA\_GROUP\_INITIAL\_REBALANCE\_DELAY\_MS: 0}: Rimuove il ritardo iniziale per il rebalance dei gruppi consumer, velocizzando l'avvio in sviluppo.
    \item \texttt{CLUSTER\_ID}: ID univoco del cluster Kafka generato per la modalità KRaft.
\end{itemize}

Per il \textbf{Consumer}, sono stati impostati i seguenti parametri critici:
\begin{itemize}
    \item \texttt{group.id}: impostato a "alert-system-group", identifica il gruppo di consumo permettendo a Kafka di gestire gli offset per questa specifica applicazione.
    \item \texttt{auto.offset.reset}: impostato a "earliest", garantisce che, in assenza di un offset salvato (es. primo avvio), il consumer legga tutti i messaggi presenti nel topic dall'inizio, evitando perdita di dati pregressi.
    \item \texttt{enable.auto.commit}: impostato a \texttt{False} per disabilitare il commit automatico degli offset, delegando all'applicazione la responsabilità di confermare l'elaborazione (come dettagliato nella sezione successiva).
\end{itemize}
Per il \textbf{Producer}, sono stati replicati gli stessi parametri di ottimizzazione utilizzati nel Data Collector (\texttt{acks='all'}, \texttt{retries=5}, \texttt{batch.size=32768}, \texttt{linger.ms=20}) per garantire che ogni allerta generata venga consegnata con successo al topic \texttt{to-notifier}, minimizzando il rischio di perdita di notifiche critiche.


\subsubsection{Strategia di Commit}
Il servizio agisce come un \textbf{Kafka Consumer}, sottoscrivendosi al topic \texttt{to-alert-system}.
Per garantire l'affidabilità dell'elaborazione ("at-least-once delivery"), è stata scelta una strategia di \textbf{Commit Manuale Sincrono} (\texttt{commitSync}).
A differenza dell'Auto Commit (che committa periodicamente in base al tempo, rischiando di perdere messaggi in caso di crash o di processarli due volte in caso di rebalance lento), il commit manuale viene eseguito solo \textit{dopo} che il messaggio è stato completamente elaborato e le eventuali notifiche sono state inviate al topic successivo.
Sebbene questa scelta possa ridurre leggermente il throughput rispetto al commit asincrono, garantisce che nessun allarme venga perso in caso di guasti.

\subsubsection{Logica di Elaborazione}
Alla ricezione di un messaggio di aggiornamento ("update\_completed"), il sistema:
\begin{enumerate}
    \item Estrae i conteggi dei voli per ogni aeroporto.
    \item Interroga il database per recuperare le preferenze degli utenti (soglie minime e massime) per quegli aeroporti.
    \item Verifica se le condizioni di allerta sono soddisfatte (es. numero di voli superiore alla soglia massima).
\end{enumerate}

Se viene rilevata un'anomalia, l'\texttt{alert-system} produce un nuovo messaggio sul topic \texttt{to-notifier}, contenente i dettagli dell'allerta (email destinatario, aeroporto, condizione violata).

Nell'immagine sotto viene fornita una visione d'insieme dell'intero flusso di notifica Kafka.

\begin{figure}[H] 
    \centering 
    \includegraphics[width=1.0\textwidth]{flusso_notifica_kafka.jpg} 
    \caption{Diagramma di sequenza del flusso di notifica Kafka.} 
    \label{fig:kafka_flow} 
\end{figure}

\subsection{Alert Notifier System}
L'\texttt{alert-notifier-system} è il componente finale della catena di allerta.
Esso consuma i messaggi dal topic \texttt{to-notifier} e si occupa dell'invio effettivo delle notifiche agli utenti.
L'invio delle email è implementato utilizzando il server SMTP di \textbf{Gmail} (\texttt{smtp.gmail.com}). 

\section{API Gateway con Nginx}
Per semplificare l'accesso ai microservizi e fornire un unico punto di ingresso (entry point) per il client, è stato introdotto \textbf{Nginx} configurato come \textit{Reverse Proxy}.
Questa configurazione permette di instradare le richieste HTTP verso i container corretti (\texttt{user-manager} o \texttt{data-collector}) in base al percorso dell'URL (es. \texttt{/users} verso User Manager, \texttt{/flights} verso Data Collector), nascondendo la complessità dell'architettura sottostante e facilitando eventuali operazioni di bilanciamento del carico in futuro.

\subsection{Sicurezza e Networking}
\begin{itemize}
    \item \textbf{Isolamento dei Servizi (expose vs ports)}: Rispetto alla versione precedente del progetto, è stata migliorata la sicurezza di rete modificando la visibilità dei container. I microservizi \textit{User Manager} e \textit{Data Collector} non espongono più le proprie porte direttamente sull'host (direttiva \texttt{ports}). Al contrario, si è optato per l'uso di \texttt{expose}, che limita l'accessibilità delle porte (5000, 5001, 50051, 50052) alla sola rete interna di Docker. Di conseguenza, l'unico punto di ingresso pubblico è la porta 80 gestita da Nginx, obbligando tutte le richieste a transitare attraverso l'API Gateway. Per quanto riguarda i database, si è scelto di mantenere temporaneamente l'accesso diretto dall'host per agevolare le attività di debug e manutenzione, con la prospettiva di rimuoverlo in produzione per blindare ulteriormente l'infrastruttura.
\end{itemize}

\subsection{Strategia di Load Balancing e Scalabilità Futura}
Nonostante l'attuale configurazione preveda una singola istanza per ogni microservizio, l'architettura di Nginx è stata predisposta per facilitare una futura scalabilità orizzontale. Attualmente, il blocco \texttt{upstream} utilizza l'algoritmo predefinito \textit{Round Robin}, adeguato per lo scenario corrente. Tuttavia, in un'ottica di espansione con repliche multiple, è stata valutata l'adozione dell'algoritmo \texttt{least\_conn}. Dato che i microservizi sono stati progettati come componenti \textit{stateless} (delegando la persistenza ai database), non vi è l'esigenza di mantenere la "session stickiness" (es. tramite \texttt{ip\_hash}). Pertanto, \texttt{least\_conn} rappresenterebbe la scelta ideale per distribuire il traffico in modo efficiente, indirizzando le nuove richieste verso l'istanza meno carica, ottimizzando così le prestazioni anche in presenza di carichi di lavoro eterogenei.

\end{document}
