1) Giustificare che su user-manager logghiamo i messaggi della cache che vengono cancellati (Counter) e il tempo di cancellazione (Gauge)
2) Data-collector invece registra come Gauge il tempo per prendere i voli e come counter il numero di voli aggiunti
3) in entrambi è stato messo un counter degli errori sollevati!!! (guarda il codice per commentarlo)
Data Collector:

Aggiunta metrica collection_errors_total con label error_type.
Strumentato il codice in services.py per incrementare il contatore in caso di:
Errori di connessione al DB.
Errori di recupero token.
Errori API OpenSky (status code != 200/404).
Circuit Breaker aperto.
Eccezioni generiche durante le richieste.
Errori di commit al DB.
Errori Kafka.
User Manager:

Aggiunta metrica user_registration_errors_total con label error_type.
Strumentato il codice in routes.py per incrementare il contatore in caso di:
Utente già esistente (user_exists).
Codice fiscale già esistente (fiscal_code_exists).
Errori interni del server (internal_server_error).

4) Aggiunto proxy nginx per prometheus + file di configurazione delle porte da utilizzare (prometheus.yml)

## Kubernetes Deployment & Evaluation

### Valutazione degli oggetti Kubernetes utilizzati

Per il deployment dell'applicazione su Kubernetes sono stati scelti i seguenti oggetti, bilanciando semplicità e best practices per un ambiente di sviluppo/test (come Kind):

1.  **Deployments**: Utilizzati per tutti i microservizi (`user-manager`, `data-collector`, `alert-system`, `alert-notifier-system`), per `nginx` e `prometheus`. I Deployment garantiscono che il numero desiderato di pod sia sempre in esecuzione e facilitano gli aggiornamenti rolling.
    *   *Nota su Kafka e Postgres*: Anche per questi servizi stateful è stato utilizzato un `Deployment` per semplicità, dato che siamo in un ambiente di test a singola istanza. In produzione, sarebbe preferibile utilizzare `StatefulSet` per garantire identità di rete stabili e gestione ordinata dello storage.

2.  **Services**: Utilizzati per esporre i pod e permettere la comunicazione interna ed esterna.
    *   `ClusterIP` (default): Usato per `postgres`, `kafka`, `user-manager`, `data-collector`, `prometheus`. Permette ai servizi di parlarsi internamente usando il nome DNS (es. `postgres:5432`).
    *   `NodePort`: Usato per `nginx` (porta 30080) per permettere l'accesso all'applicazione dall'host locale (la macchina dello sviluppatore).

3.  **ConfigMaps**: Utilizzate per disaccoppiare la configurazione dal codice.
    *   `postgres-init-script`: Contiene lo script SQL di inizializzazione (`init.sql`).
    *   `prometheus-config`: Contiene la configurazione di scraping (`prometheus.yml`).
    *   `nginx-config`: Contiene la configurazione del reverse proxy (`nginx.conf`).

4.  **Secrets**: Utilizzati per gestire dati sensibili come password e chiavi API (`app-secrets`). Questo evita di scrivere credenziali in chiaro nei manifest.

5.  **PersistentVolumeClaim (PVC)**: Utilizzato per `postgres` per garantire che i dati del database sopravvivano al riavvio del pod.

### Spiegazione dei Manifest

I file `.yaml` nella cartella `k8s/` definiscono l'infrastruttura:

*   **postgres.yaml**: Definisce il DB. Monta un volume persistente e lo script di init tramite ConfigMap.
*   **kafka.yaml**: Configura Kafka in modalità KRaft (senza Zookeeper) tramite variabili d'ambiente, esponendo la porta 9092.
*   **user-manager.yaml & data-collector.yaml**: Definiscono i microservizi. Espongono porte HTTP, gRPC e Metrics (Prometheus). Usano variabili d'ambiente per connettersi al DB.
*   **alert-system.yaml & alert-notifier-system.yaml**: Worker che consumano messaggi da Kafka. Non hanno bisogno di Service in ingresso.
*   **prometheus.yaml**: Configura il server di monitoraggio. Monta il file di configurazione che definisce i target da monitorare (`user-manager` e `data-collector`).
*   **nginx.yaml**: Il punto di ingresso. Configurato come NodePort sulla porta 30080. Fa da reverse proxy verso i servizi e Prometheus.
*   **secrets.yaml**: Template per le credenziali. **Importante**: Devi inserire i valori base64 delle tue chiavi prima di applicarlo.

### Istruzioni per il Deployment (Kind)

1.  **Creare il cluster**: `kind create cluster`
2.  **Build delle immagini**:
    ```bash
    docker build -t homework3-user-manager:latest -f user-manager/Dockerfile .
    docker build -t homework3-data-collector:latest -f data-collector/Dockerfile .
    docker build -t homework3-alert-system:latest -f alert-system/Dockerfile .
    docker build -t homework3-alert-notifier-system:latest -f alert-notifier-system/Dockerfile .
    ```
3.  **Caricare le immagini in Kind**:
    ```bash
    kind load docker-image homework3-user-manager:latest
    kind load docker-image homework3-data-collector:latest
    kind load docker-image homework3-alert-system:latest
    kind load docker-image homework3-alert-notifier-system:latest
    ```
4.  **Applicare i manifest**:
    ```bash
    kubectl apply -f k8s/secrets.yaml # (Dopo averlo compilato)
    kubectl apply -f k8s/
    ```
5.  **Accesso**: L'app sarà disponibile su `http://localhost:30080`.
Errori interni del server (internal_server_error).

4) Aggiunto proxy nginx per prometheus + file di configurazione delle porte da utilizzare (prometheus.yml)
5)